#[cfg(test)]
mod tests {
    use ntex::web::types::Json;
    use types::{error::ApiError, DeviceRegistrationToken, NotificationKey};

    use crate::{
        notification_mocks::{
            MockFCM, MockRedisConnection, MockRegisterDeviceReq,
            MockUnregisterDeviceReq, MockUserMetadata,
        },
        notifications::{register_device_impl, send_notification_impl, unregister_device_impl},
    };

    fn create_mock_user_metadata(
        user_id: &str,
        notification_key: Option<NotificationKey>,
    ) -> MockUserMetadata {
        MockUserMetadata {
            user_canister_id: user_id.to_string(),
            user_name: format!("user_{}", user_id),
            notification_key,
        }
    }

    #[tokio::test]
    async fn test_register_device_new_user_creates_key() {
        let mut mock_fcm = MockFCM::new();
        let mut mock_redis = MockRedisConnection::new();
        let user_principal_text = "aaaaa-aa"; // A valid principal string

        // User does not exist in Redis yet.
        // The register_device_impl expects metadata to exist to proceed with key creation logic.
        // If meta_raw is None, it returns ApiError::MetadataNotFound.
        // So, we must add the user to mock_redis first, but without a notification key.
        let initial_metadata: MockUserMetadata =
            create_mock_user_metadata(user_principal_text, None);
        mock_redis.users.push(initial_metadata);

        let req = Json(MockRegisterDeviceReq {
            registration_token: DeviceRegistrationToken {
                token: "new_device_token_1".to_string(),
            },
        });

        let result = register_device_impl(
            user_principal_text.to_string(),
            req,
            &mut mock_fcm,
            &mut mock_redis,
        )
        .await;

        assert!(result.is_ok(), "Registration failed: {:?}", result.err());
        let api_result = result.unwrap().0;
        assert!(
            api_result.is_ok(),
            "API result was an error: {:?}",
            api_result.err()
        );

        // Check FCM: device group should be created
        let notification_key_name =
            crate::firebase::notifications::utils::get_notification_key_name_from_principal(
                &user_principal_text.to_string(),
            );
        assert!(mock_fcm
            .notification_groups
            .contains_key(&notification_key_name));
        let group = mock_fcm
            .notification_groups
            .get(&notification_key_name)
            .unwrap();
        assert_eq!(group.registration_tokens.len(), 1);
        assert_eq!(group.registration_tokens[0], "new_device_token_1");
        let fcm_notification_key = group.notification_key.clone(); // Key generated by FCM mock

        // Check Redis: user metadata should be updated with the new notification key
        let updated_metadata = mock_redis
            .hget(user_principal_text)
            .await
            .unwrap()
            .expect("User metadata not found after registration");

        assert!(updated_metadata.notification_key.is_some());
        let redis_notification_key = updated_metadata.notification_key.as_ref().unwrap();
        assert_eq!(redis_notification_key.key, fcm_notification_key); // Ensure key from FCM is stored
        assert_eq!(redis_notification_key.registration_tokens.len(), 1);
        assert_eq!(
            redis_notification_key.registration_tokens[0].token,
            "new_device_token_1"
        );
    }

    #[tokio::test]
    async fn test_register_device_existing_user_adds_to_key() {
        let mut mock_fcm = MockFCM::new();
        let mut mock_redis = MockRedisConnection::new();
        let user_principal_text = "bbbbb-bb";

        let initial_fcm_key = "existing_fcm_key_for_bbbbb-bb".to_string();
        let existing_token = "existing_device_token_1".to_string();

        // Pre-populate Redis with user metadata and an existing notification key
        let initial_metadata = create_mock_user_metadata(
            user_principal_text,
            Some(NotificationKey {
                key: initial_fcm_key.clone(),
                registration_tokens: vec![DeviceRegistrationToken {
                    token: existing_token.clone(),
                }],
            }),
        );
        mock_redis.users.push(initial_metadata);

        // Pre-populate FCM with the corresponding device group
        let notification_key_name =
            crate::firebase::notifications::utils::get_notification_key_name_from_principal(
                &user_principal_text.to_string(),
            );
        mock_fcm.notification_groups.insert(
            notification_key_name.clone(),
            crate::notification_mocks::DeviceGroup {
                notification_key: initial_fcm_key.clone(),
                registration_tokens: vec![existing_token.clone()],
            },
        );

        let new_device_token_str = "new_device_token_2".to_string();
        let req = Json(MockRegisterDeviceReq {
            registration_token: DeviceRegistrationToken {
                token: new_device_token_str.clone(),
            },
        });

        let result = register_device_impl(
            user_principal_text.to_string(),
            req,
            &mut mock_fcm,
            &mut mock_redis,
        )
        .await;

        assert!(result.is_ok(), "Registration failed: {:?}", result.err());
        let api_result = result.unwrap().0;
        assert!(
            api_result.is_ok(),
            "API result was an error: {:?}",
            api_result.err()
        );

        // Check FCM: new device should be added to the existing group
        assert!(mock_fcm
            .notification_groups
            .contains_key(&notification_key_name));
        let group = mock_fcm
            .notification_groups
            .get(&notification_key_name)
            .unwrap();
        assert_eq!(group.registration_tokens.len(), 2);
        assert!(group.registration_tokens.contains(&existing_token));
        assert!(group.registration_tokens.contains(&new_device_token_str));
        // The key itself should remain the same as it was an "add" operation
        assert_eq!(group.notification_key, initial_fcm_key);

        // Check Redis: user metadata should be updated
        let updated_metadata = mock_redis
            .hget(user_principal_text)
            .await
            .unwrap()
            .expect("User metadata not found after registration");

        let redis_notification_key = updated_metadata.notification_key.as_ref().unwrap();
        assert_eq!(redis_notification_key.key, initial_fcm_key); // Key from FCM should be the original one
        assert_eq!(redis_notification_key.registration_tokens.len(), 2);
        assert!(redis_notification_key
            .registration_tokens
            .iter()
            .any(|rt| rt.token == existing_token));
        assert!(redis_notification_key
            .registration_tokens
            .iter()
            .any(|rt| rt.token == new_device_token_str));
    }

    #[tokio::test]
    async fn test_register_device_reregister_existing_token() {
        let mut mock_fcm = MockFCM::new();
        let mut mock_redis = MockRedisConnection::new();
        let user_principal_text = "ccccc-cc";

        let initial_fcm_key = "existing_fcm_key_for_ccccc-cc".to_string();
        let existing_token_str = "device_token_to_reregister".to_string();

        let initial_metadata = create_mock_user_metadata(
            user_principal_text,
            Some(NotificationKey {
                key: initial_fcm_key.clone(),
                registration_tokens: vec![DeviceRegistrationToken {
                    token: existing_token_str.clone(),
                }],
            }),
        );
        mock_redis.users.push(initial_metadata);

        let notification_key_name =
            crate::firebase::notifications::utils::get_notification_key_name_from_principal(
                &user_principal_text.to_string(),
            );
        mock_fcm.notification_groups.insert(
            notification_key_name.clone(),
            crate::notification_mocks::DeviceGroup {
                notification_key: initial_fcm_key.clone(),
                registration_tokens: vec![existing_token_str.clone()],
            },
        );

        let req = Json(MockRegisterDeviceReq {
            registration_token: DeviceRegistrationToken {
                // Same token
                token: existing_token_str.clone(),
            },
        });

        let result = register_device_impl(
            user_principal_text.to_string(),
            req,
            &mut mock_fcm,
            &mut mock_redis,
        )
        .await;

        assert!(result.is_ok(), "Registration failed: {:?}", result.err());
        let api_result = result.unwrap().0;
        assert!(
            api_result.is_ok(),
            "API result was an error: {:?}",
            api_result.err()
        );

        // Check FCM: token should be removed and then added. Net effect: still there, count is 1.
        // The mock FCM's update_notification_devices for Remove then Add might not change the key if the group remains.
        // The actual implementation logic for re-registration first removes then adds.
        let group = mock_fcm
            .notification_groups
            .get(&notification_key_name)
            .unwrap();
        assert_eq!(group.registration_tokens.len(), 1);
        assert_eq!(group.registration_tokens[0], existing_token_str);
        assert_eq!(group.notification_key, notification_key_name.as_str()); // Key should be the recreated one

        // Check Redis: metadata should reflect one token and the new key
        let updated_metadata = mock_redis
            .hget(user_principal_text)
            .await
            .unwrap()
            .expect("User metadata not found");
        let redis_notification_key = updated_metadata.notification_key.as_ref().unwrap();
        assert_eq!(redis_notification_key.key, notification_key_name.as_str()); // Key in Redis also updated
        assert_eq!(redis_notification_key.registration_tokens.len(), 1);
        assert_eq!(
            redis_notification_key.registration_tokens[0].token,
            existing_token_str
        );
    }

    #[tokio::test]
    async fn test_register_device_metadata_not_found() {
        let mut mock_fcm = MockFCM::new();
        let mut mock_redis = MockRedisConnection::new(); // Empty redis
        let user_principal_text = "ddddd-dd";

        let req = Json(MockRegisterDeviceReq {
            registration_token: DeviceRegistrationToken {
                token: "some_token".to_string(),
            },
        });

        let result = register_device_impl(
            user_principal_text.to_string(),
            req,
            &mut mock_fcm,
            &mut mock_redis,
        )
        .await;

        assert!(result.is_ok(), "Call itself should be ok");
        let api_result = result.unwrap().0;
        assert!(api_result.is_err(), "API result should be an error");
        assert_eq!(api_result.err(), Some(ApiError::MetadataNotFound));
    }

    // --- Unregister Device Tests ---

    #[tokio::test]
    async fn test_unregister_device_success() {
        let mut mock_fcm = MockFCM::new();
        let mut mock_redis = MockRedisConnection::new();
        let user_principal_text = "eeeee-ee";
        let token_to_unregister = "token_to_remove".to_string();
        let other_token = "other_token_kept".to_string();
        let fcm_key = "fcm_key_for_eeeee-ee".to_string();

        let initial_metadata = create_mock_user_metadata(
            user_principal_text,
            Some(NotificationKey {
                key: fcm_key.clone(),
                registration_tokens: vec![
                    DeviceRegistrationToken {
                        token: token_to_unregister.clone(),
                    },
                    DeviceRegistrationToken {
                        token: other_token.clone(),
                    },
                ],
            }),
        );
        mock_redis.users.push(initial_metadata);

        let notification_key_name =
            crate::firebase::notifications::utils::get_notification_key_name_from_principal(
                &user_principal_text.to_string(),
            );
        mock_fcm.notification_groups.insert(
            notification_key_name.clone(),
            crate::notification_mocks::DeviceGroup {
                notification_key: fcm_key.clone(),
                registration_tokens: vec![token_to_unregister.clone(), other_token.clone()],
            },
        );

        let req = Json(MockUnregisterDeviceReq {
            registration_token: DeviceRegistrationToken {
                token: token_to_unregister.clone(),
            },
        });

        let result = unregister_device_impl(
            user_principal_text.to_string(),
            req,
            &mut mock_fcm,
            &mut mock_redis,
        )
        .await;

        assert!(result.is_ok(), "Unregistration failed: {:?}", result.err());
        let api_result = result.unwrap().0;
        assert!(
            api_result.is_ok(),
            "API result was an error: {:?}",
            api_result.err()
        );

        // Check FCM: token should be removed
        let group = mock_fcm
            .notification_groups
            .get(&notification_key_name)
            .unwrap();
        assert_eq!(group.registration_tokens.len(), 1);
        assert_eq!(group.registration_tokens[0], other_token);

        // Check Redis: token should be removed from metadata
        let updated_metadata = mock_redis
            .hget(user_principal_text)
            .await
            .unwrap()
            .expect("User metadata not found");
        let redis_notification_key = updated_metadata.notification_key.as_ref().unwrap();
        assert_eq!(redis_notification_key.registration_tokens.len(), 1);
        assert_eq!(
            redis_notification_key.registration_tokens[0].token,
            other_token
        );
    }

    #[tokio::test]
    async fn test_unregister_last_device_removes_group_from_fcm() {
        let mut mock_fcm = MockFCM::new();
        let mut mock_redis = MockRedisConnection::new();
        let user_principal_text = "fffff-ff";
        let last_token = "the_last_token".to_string();
        let fcm_key = "fcm_key_for_fffff-ff".to_string();

        let initial_metadata = create_mock_user_metadata(
            user_principal_text,
            Some(NotificationKey {
                key: fcm_key.clone(),
                registration_tokens: vec![DeviceRegistrationToken {
                    token: last_token.clone(),
                }],
            }),
        );
        mock_redis.users.push(initial_metadata);

        let notification_key_name =
            crate::firebase::notifications::utils::get_notification_key_name_from_principal(
                &user_principal_text.to_string(),
            );
        mock_fcm.notification_groups.insert(
            notification_key_name.clone(),
            crate::notification_mocks::DeviceGroup {
                notification_key: fcm_key.clone(),
                registration_tokens: vec![last_token.clone()],
            },
        );

        let req = Json(MockUnregisterDeviceReq {
            registration_token: DeviceRegistrationToken {
                token: last_token.clone(),
            },
        });

        let result = unregister_device_impl(
            user_principal_text.to_string(),
            req,
            &mut mock_fcm,
            &mut mock_redis,
        )
        .await;

        assert!(result.is_ok(), "Unregistration failed: {:?}", result.err());
        let api_result = result.unwrap().0;
        assert!(
            api_result.is_ok(),
            "API result was an error: {:?}",
            api_result.err()
        );

        // Check FCM: group should be removed as it was the last token
        assert!(!mock_fcm
            .notification_groups
            .contains_key(&notification_key_name));

        // Check Redis: token list should be empty, but key might remain.
        // The current unregister_device_impl keeps the NotificationKey struct in metadata but empties its registration_tokens.
        // This seems reasonable.
        let updated_metadata = mock_redis
            .hget(user_principal_text)
            .await
            .unwrap()
            .expect("User metadata not found");
        let redis_notification_key = updated_metadata.notification_key.as_ref().unwrap();
        assert!(redis_notification_key.registration_tokens.is_empty());
        assert_eq!(redis_notification_key.key, fcm_key); // Key itself remains in metadata
    }

    #[tokio::test]
    async fn test_unregister_device_not_found() {
        let mut mock_fcm = MockFCM::new();
        let mut mock_redis = MockRedisConnection::new();
        let user_principal_text = "ggggg-gg";
        let existing_token = "actual_token".to_string();
        let token_to_unregister = "non_existent_token".to_string();
        let fcm_key = "fcm_key_for_ggggg-gg".to_string();

        let initial_metadata = create_mock_user_metadata(
            user_principal_text,
            Some(NotificationKey {
                key: fcm_key.clone(),
                registration_tokens: vec![DeviceRegistrationToken {
                    token: existing_token.clone(),
                }],
            }),
        );
        mock_redis.users.push(initial_metadata);

        let notification_key_name =
            crate::firebase::notifications::utils::get_notification_key_name_from_principal(
                &user_principal_text.to_string(),
            );
        mock_fcm.notification_groups.insert(
            notification_key_name.clone(),
            crate::notification_mocks::DeviceGroup {
                notification_key: fcm_key.clone(),
                registration_tokens: vec![existing_token.clone()],
            },
        );

        let req = Json(MockUnregisterDeviceReq {
            registration_token: DeviceRegistrationToken {
                token: token_to_unregister.clone(),
            },
        });

        let result = unregister_device_impl(
            user_principal_text.to_string(),
            req,
            &mut mock_fcm,
            &mut mock_redis,
        )
        .await;

        assert!(result.is_ok(), "Call itself should be ok");
        let api_result = result.unwrap().0;
        assert!(api_result.is_err(), "API result should be an error");
        assert_eq!(api_result.err(), Some(ApiError::DeviceNotFound));

        // Ensure FCM and Redis state are unchanged
        let group = mock_fcm
            .notification_groups
            .get(&notification_key_name)
            .unwrap();
        assert_eq!(group.registration_tokens.len(), 1);
        assert_eq!(group.registration_tokens[0], existing_token);

        let metadata = mock_redis.hget(user_principal_text).await.unwrap().unwrap();
        assert_eq!(
            metadata
                .notification_key
                .as_ref()
                .unwrap()
                .registration_tokens
                .len(),
            1
        );
    }

    #[tokio::test]
    async fn test_unregister_device_no_notification_key() {
        let mut mock_fcm = MockFCM::new();
        let mut mock_redis = MockRedisConnection::new();
        let user_principal_text = "hhhhh-hh";

        // User exists but has no notification key
        let initial_metadata = create_mock_user_metadata(user_principal_text, None);
        mock_redis.users.push(initial_metadata);

        let req = Json(MockUnregisterDeviceReq {
            registration_token: DeviceRegistrationToken {
                token: "any_token".to_string(),
            },
        });

        let result = unregister_device_impl(
            user_principal_text.to_string(),
            req,
            &mut mock_fcm,
            &mut mock_redis,
        )
        .await;

        assert!(result.is_ok(), "Call itself should be ok");
        let api_result = result.unwrap().0;
        assert!(api_result.is_err(), "API result should be an error");
        assert_eq!(api_result.err(), Some(ApiError::NotificationKeyNotFound));
    }

    #[tokio::test]
    async fn test_unregister_device_metadata_not_found() {
        let mut mock_fcm = MockFCM::new();
        let mut mock_redis = MockRedisConnection::new(); // Empty redis
        let user_principal_text = "iiiii-ii";

        let req = Json(MockUnregisterDeviceReq {
            registration_token: DeviceRegistrationToken {
                token: "any_token".to_string(),
            },
        });

        let result = unregister_device_impl(
            user_principal_text.to_string(),
            req,
            &mut mock_fcm,
            &mut mock_redis,
        )
        .await;

        assert!(result.is_ok(), "Call itself should be ok");
        let api_result = result.unwrap().0;
        assert!(api_result.is_err(), "API result should be an error");
        assert_eq!(api_result.err(), Some(ApiError::MetadataNotFound));
    }

    // --- Send Notification Tests ---
    // NOTE: send_notification_impl takes user_principal: Path<Principal>
    // which is harder to mock directly without a request context.
    // For these tests to pass easily, send_notification_impl would ideally also take
    // user_principal: String under #[cfg(test)], like the other two _impl functions.
    // Assuming for now that we can adapt or that this might be changed.
    // If not, these tests would need a way to construct Path<Principal>.

    // For now, I'll skip send_notification_impl tests as they need Path<Principal> or a change in the target function.
    // I will revisit this if you confirm how to handle Path<Principal> or if you want to modify send_notification_impl for testing.

    #[tokio::test]
    async fn test_send_notification_success() {
        let mut mock_fcm = MockFCM::new();
        let mut mock_redis = MockRedisConnection::new();
        let user_principal_text = "jjjjj-jj";
        let fcm_key = "fcm_key_for_jjjjj-jj".to_string();
        let device_token = "device_for_jjjjj".to_string();

        let initial_metadata = create_mock_user_metadata(
            user_principal_text,
            Some(NotificationKey {
                key: fcm_key.clone(),
                registration_tokens: vec![DeviceRegistrationToken {
                    token: device_token.clone(),
                }],
            }),
        );
        mock_redis.users.push(initial_metadata);

        // Mock FCM group
        let notification_key_name =
            crate::firebase::notifications::utils::get_notification_key_name_from_principal(
                &user_principal_text.to_string(),
            );
        mock_fcm.notification_groups.insert(
            notification_key_name.clone(),
            crate::notification_mocks::DeviceGroup {
                notification_key: fcm_key.clone(),
                registration_tokens: vec![device_token.clone()],
            },
        );

        let notification_payload = types::NotificationPayload {
            title: "Test Title".to_string(),
            body: "Test Body".to_string(),
        };
        let req = Json(types::SendNotificationReq {
            data: notification_payload.clone(),
        });

        let result = send_notification_impl(
            user_principal_text.to_string(),
            req,
            &mut mock_fcm,
            &mut mock_redis,
        )
        .await;

        assert!(
            result.is_ok(),
            "send_notification_impl failed: {:?}",
            result.err()
        );
        let api_result = result.unwrap().0;
        assert!(
            api_result.is_ok(),
            "API result was an error: {:?}",
            api_result.err()
        );

        // We can't easily check if MockFCM::send_message_to_group was called with the right params
        // without modifying the mock to record calls, or by observing side effects (like println).
        // For now, success means no errors were returned and the function ran.
    }

    #[tokio::test]
    async fn test_send_notification_metadata_not_found() {
        let mut mock_fcm = MockFCM::new();
        let mut mock_redis = MockRedisConnection::new(); // Empty redis
        let user_principal_text = "kkkkk-kk";

        let notification_payload = types::NotificationPayload {
            title: "Test Title".to_string(),
            body: "Test Body".to_string(),
        };
        let req = Json(types::SendNotificationReq {
            data: notification_payload,
        });

        let result = send_notification_impl(
            user_principal_text.to_string(),
            req,
            &mut mock_fcm,
            &mut mock_redis,
        )
        .await;

        assert!(result.is_ok(), "Call itself should be Ok");
        let api_result = result.unwrap().0;
        assert!(api_result.is_err(), "API result should be an error");
        assert_eq!(api_result.err(), Some(ApiError::MetadataNotFound));
    }

    #[tokio::test]
    async fn test_send_notification_key_not_found_in_metadata() {
        let mut mock_fcm = MockFCM::new();
        let mut mock_redis = MockRedisConnection::new();
        let user_principal_text = "lllll-ll";

        // User exists but has no notification key in their metadata
        let initial_metadata = create_mock_user_metadata(user_principal_text, None);
        mock_redis.users.push(initial_metadata);

        let notification_payload = types::NotificationPayload {
            title: "Test Title".to_string(),
            body: "Test Body".to_string(),
        };
        let req = Json(types::SendNotificationReq {
            data: notification_payload,
        });

        let result = send_notification_impl(
            user_principal_text.to_string(),
            req,
            &mut mock_fcm,
            &mut mock_redis,
        )
        .await;

        assert!(result.is_ok(), "Call itself should be Ok");
        let api_result = result.unwrap().0;
        assert!(api_result.is_err(), "API result should be an error");
        assert_eq!(api_result.err(), Some(ApiError::NotificationKeyNotFound));
    }

    // MockFCM::send_message_to_group itself can return an Error::Unknown
    // if the notification_key is not found in its internal map.
    // This scenario would be if metadata has a key, but FCM doesn't know it.
    #[tokio::test]
    async fn test_send_notification_fcm_key_not_found_in_fcm_mock() {
        let mut mock_fcm = MockFCM::new(); // FCM mock is empty
        let mut mock_redis = MockRedisConnection::new();
        let user_principal_text = "mmmmm-mm";
        let fcm_key_in_redis = "dangling_fcm_key_in_redis".to_string();

        // User metadata has a notification key
        let initial_metadata = create_mock_user_metadata(
            user_principal_text,
            Some(NotificationKey {
                key: fcm_key_in_redis.clone(),
                registration_tokens: vec![DeviceRegistrationToken {
                    token: "some_device".to_string(),
                }],
            }),
        );
        mock_redis.users.push(initial_metadata);

        // BUT, mock_fcm does NOT have this key in its notification_groups.

        let notification_payload = types::NotificationPayload {
            title: "Test Title".to_string(),
            body: "Test Body".to_string(),
        };
        let req = Json(types::SendNotificationReq {
            data: notification_payload.clone(),
        });

        let result = send_notification_impl(
            user_principal_text.to_string(),
            req,
            &mut mock_fcm,
            &mut mock_redis,
        )
        .await;

        // The send_notification_impl function calls mock_fcm.send_message_to_group,
        // which will return an Err(Error::Unknown) if the key is not found in the mock FCM.
        // This error is then propagated by send_notification_impl.
        assert!(
            result.is_err(),
            "send_notification_impl should have failed due to FCM error"
        );
        match result.err().unwrap() {
            crate::utils::error::Error::Unknown(msg) => {
                assert!(msg.contains(&format!(
                    "Notification key not found: {:?}",
                    fcm_key_in_redis
                )));
            }
            _ => panic!("Expected Error::Unknown from send_notification_impl"),
        }
    }

    // --- New tests for out-of-sync scenarios ---

    #[tokio::test]
    async fn test_register_device_fcm_has_key_redis_missing_key_struct() {
        let mut mock_fcm = MockFCM::new();
        let mut mock_redis = MockRedisConnection::new();
        let user_principal_text = "nnnnn-nn";

        // Setup: User metadata in Redis *without* a notification_key struct.
        let initial_metadata_no_key = create_mock_user_metadata(user_principal_text, None);
        mock_redis.users.push(initial_metadata_no_key);

        // Setup: FCM already has a notification group for this user.
        let notification_key_name =
            crate::firebase::notifications::utils::get_notification_key_name_from_principal(
                &user_principal_text.to_string(),
            );
        let fcm_existing_key = format!("fcm_key_for_{}", user_principal_text);
        mock_fcm.notification_groups.insert(
            notification_key_name.clone(),
            crate::notification_mocks::DeviceGroup {
                notification_key: fcm_existing_key.clone(),
                registration_tokens: vec!["old_token_in_fcm".to_string()], // Group exists with a token
            },
        );
        // This setup simulates FCM returning "notification_key_name exists" during a create attempt,
        // and providing the existing_key. The mock needs to be able to do this.
        // For this test to work as intended, MockFCM::update_notification_devices(Create, ...)
        // should return Err(Error::FirebaseApiErr( containing the existing fcm_existing_key ))
        // if notification_key_name already exists in mock_fcm.notification_groups.


        let new_device_token_str = "new_device_for_nnnnn".to_string();
        let req = Json(MockRegisterDeviceReq {
            registration_token: DeviceRegistrationToken {
                token: new_device_token_str.clone(),
            },
        });

        let result = register_device_impl(
            user_principal_text.to_string(),
            req,
            &mut mock_fcm,
            &mut mock_redis,
        )
        .await;

        assert!(result.is_ok(), "Registration failed: {:?}", result.err());
        let api_result = result.unwrap().0;
        assert!(
            api_result.is_ok(),
            "API result was an error: {:?}",
            api_result.err()
        );

        // Check FCM: new device should be added to the existing group.
        let group = mock_fcm
            .notification_groups
            .get(&notification_key_name)
            .expect("FCM group should still exist");
        assert_eq!(group.notification_key, fcm_existing_key); // Should use the existing key from FCM
        assert_eq!(group.registration_tokens.len(), 2); // old_token_in_fcm + new_device_for_nnnnn
        assert!(group.registration_tokens.contains(&"old_token_in_fcm".to_string()));
        assert!(group.registration_tokens.contains(&new_device_token_str));


        // Check Redis: user metadata should be updated with the existing FCM key and new token.
        let updated_metadata = mock_redis
            .hget(user_principal_text)
            .await
            .unwrap()
            .expect("User metadata not found after registration");
        let redis_notification_key = updated_metadata
            .notification_key
            .as_ref()
            .expect("Notification key should exist in Redis");
        assert_eq!(redis_notification_key.key, fcm_existing_key);
        assert_eq!(redis_notification_key.registration_tokens.len(), 1); // Only new token if old wasn't tracked, or both if merged.
                                                                        // Current impl will add the new token and ensure old ones are present if the key matches.
                                                                        // Given the scenario, it should fetch the state from FCM as source of truth.
                                                                        // The current register_impl will overwrite tokens list with just the new one after add.
        assert!(redis_notification_key.registration_tokens.iter().any(|rt| rt.token == new_device_token_str));
        // The current implementation, after finding an existing key via the "create then add" path,
        // effectively re-constructs the token list in Redis with just the newly registered token.
        // If the goal is to merge with FCM's list, the impl would need to fetch tokens from FCM.
        // For this test, we assert the current behavior: Redis has the new token and the key from FCM.
        // If `old_token_in_fcm` was not part of the `add_body`'s registration_token, it won't be in redis.
        // The `add_body` is constructed with only the `registration_token.token`.
        // So Redis will have fcm_existing_key and only new_device_token_str
         assert_eq!(redis_notification_key.registration_tokens.len(), 1, "Redis should only have the newly registered token under the existing key");


    }

    #[tokio::test]
    async fn test_register_device_fcm_missing_key_redis_has_key() {
        let mut mock_fcm = MockFCM::new(); // FCM is empty
        let mut mock_redis = MockRedisConnection::new();
        let user_principal_text = "ooooo-oo";
        let redis_stale_key = "stale_fcm_key_in_redis".to_string();

        // Setup: User metadata in Redis *with* a notification_key, but FCM has no corresponding group.
        let initial_metadata_stale_key = create_mock_user_metadata(
            user_principal_text,
            Some(NotificationKey {
                key: redis_stale_key.clone(),
                registration_tokens: vec![DeviceRegistrationToken {
                    token: "old_token_in_redis".to_string(),
                }],
            }),
        );
        mock_redis.users.push(initial_metadata_stale_key);

        // FCM mock is empty, so an "add" operation to `redis_stale_key` will fail.
        // MockFCM::update_notification_devices(Add, ...) should return Err(Error::FirebaseApiErr("notification_key not found".to_string()))

        let new_device_token_str = "new_device_for_ooooo".to_string();
        let req = Json(MockRegisterDeviceReq {
            registration_token: DeviceRegistrationToken {
                token: new_device_token_str.clone(),
            },
        });

        let result = register_device_impl(
            user_principal_text.to_string(),
            req,
            &mut mock_fcm,
            &mut mock_redis,
        )
        .await;

        assert!(result.is_ok(), "Registration failed: {:?}", result.err());
        let api_result = result.unwrap().0;
        assert!(
            api_result.is_ok(),
            "API result was an error: {:?}",
            api_result.err()
        );

        // Check FCM: a new group should be created.
        let notification_key_name =
            crate::firebase::notifications::utils::get_notification_key_name_from_principal(
                &user_principal_text.to_string(),
            );
        assert!(mock_fcm
            .notification_groups
            .contains_key(&notification_key_name));
        let group = mock_fcm
            .notification_groups
            .get(&notification_key_name)
            .unwrap();
        assert_eq!(group.registration_tokens.len(), 1);
        assert_eq!(group.registration_tokens[0], new_device_token_str);
        let fcm_new_key = group.notification_key.clone(); // This key is generated by mock_fcm.create

        // Check Redis: metadata should be updated with the new key from FCM.
        let updated_metadata = mock_redis
            .hget(user_principal_text)
            .await
            .unwrap()
            .expect("User metadata not found");
        let redis_notification_key = updated_metadata.notification_key.as_ref().unwrap();
        assert_eq!(redis_notification_key.key, fcm_new_key);
        assert_eq!(redis_notification_key.registration_tokens.len(), 1);
        assert_eq!(
            redis_notification_key.registration_tokens[0].token,
            new_device_token_str
        );
    }

    #[tokio::test]
    async fn test_unregister_device_token_in_redis_not_in_fcm_group_exists() {
        let mut mock_fcm = MockFCM::new();
        let mut mock_redis = MockRedisConnection::new();
        let user_principal_text = "ppppp-pp";
        let token_in_redis_only = "token_in_redis_not_fcm".to_string();
        let token_in_both = "token_in_both_systems".to_string();
        let fcm_key = "fcm_key_for_ppppp-pp".to_string();

        // Setup: Redis has two tokens.
        let initial_metadata = create_mock_user_metadata(
            user_principal_text,
            Some(NotificationKey {
                key: fcm_key.clone(),
                registration_tokens: vec![
                    DeviceRegistrationToken { token: token_in_redis_only.clone() },
                    DeviceRegistrationToken { token: token_in_both.clone() },
                ],
            }),
        );
        mock_redis.users.push(initial_metadata);

        // Setup: FCM group exists, but only has one of the tokens.
        let notification_key_name =
            crate::firebase::notifications::utils::get_notification_key_name_from_principal(
                &user_principal_text.to_string(),
            );
        mock_fcm.notification_groups.insert(
            notification_key_name.clone(),
            crate::notification_mocks::DeviceGroup {
                notification_key: fcm_key.clone(),
                registration_tokens: vec![token_in_both.clone()], // Missing token_in_redis_only
            },
        );
        // MockFCM::update_notification_devices(Remove, token_in_redis_only)
        // should return an error like Error::FirebaseApiErr("Token not found in group".to_string()) or "INVALID_ARGUMENT"

        let req = Json(MockUnregisterDeviceReq {
            registration_token: DeviceRegistrationToken { token: token_in_redis_only.clone() },
        });

        let result = unregister_device_impl(
            user_principal_text.to_string(),
            req,
            &mut mock_fcm,
            &mut mock_redis,
        ).await;

        assert!(result.is_ok(), "Unregistration call failed: {:?}", result.err());
        let api_result = result.unwrap().0;
        // This assertion depends on unregister_device_impl handling the "token not found in FCM" gracefully
        assert!(api_result.is_ok(), "API result should be Ok, even if token was not in FCM: {:?}", api_result.err());

        // Check FCM: group should be unchanged (as the token wasn't there to begin with).
        let group = mock_fcm.notification_groups.get(&notification_key_name).unwrap();
        assert_eq!(group.registration_tokens.len(), 1);
        assert_eq!(group.registration_tokens[0], token_in_both);

        // Check Redis: token_in_redis_only should be removed.
        let updated_metadata = mock_redis.hget(user_principal_text).await.unwrap().unwrap();
        let redis_nk = updated_metadata.notification_key.as_ref().unwrap();
        assert_eq!(redis_nk.registration_tokens.len(), 1);
        assert_eq!(redis_nk.registration_tokens[0].token, token_in_both);
    }

    #[tokio::test]
    async fn test_unregister_device_token_in_redis_fcm_group_gone() {
        let mut mock_fcm = MockFCM::new(); // FCM is empty
        let mut mock_redis = MockRedisConnection::new();
        let user_principal_text = "qqqqq-qq";
        let token_to_unregister = "token_when_fcm_group_is_gone".to_string();
        let fcm_key_in_redis = "fcm_key_for_qqqqq-qq_gone_from_fcm".to_string();

        // Setup: Redis has a token and a notification key.
        let initial_metadata = create_mock_user_metadata(
            user_principal_text,
            Some(NotificationKey {
                key: fcm_key_in_redis.clone(),
                registration_tokens: vec![
                    DeviceRegistrationToken { token: token_to_unregister.clone() },
                ],
            }),
        );
        mock_redis.users.push(initial_metadata);

        // Setup: FCM has no corresponding group for this user.
        // MockFCM::update_notification_devices(Remove, ...)
        // should return an error like Error::FirebaseApiErr("notification_key not found".to_string())

        let req = Json(MockUnregisterDeviceReq {
            registration_token: DeviceRegistrationToken { token: token_to_unregister.clone() },
        });

        let result = unregister_device_impl(
            user_principal_text.to_string(),
            req,
            &mut mock_fcm,
            &mut mock_redis,
        ).await;

        assert!(result.is_ok(), "Unregistration call failed: {:?}", result.err());
        let api_result = result.unwrap().0;
        // This assertion depends on unregister_device_impl handling "group not found in FCM" gracefully
        assert!(api_result.is_ok(), "API result should be Ok, even if group was not in FCM: {:?}", api_result.err());

        // Check FCM: still no group for this user.
        let notification_key_name =
            crate::firebase::notifications::utils::get_notification_key_name_from_principal(
                &user_principal_text.to_string(),
            );
        assert!(!mock_fcm.notification_groups.contains_key(&notification_key_name));

        // Check Redis: token should be removed, key might still be there but with empty tokens.
        let updated_metadata = mock_redis.hget(user_principal_text).await.unwrap().unwrap();
        let redis_nk = updated_metadata.notification_key.as_ref().unwrap();
        assert!(redis_nk.registration_tokens.is_empty());
        assert_eq!(redis_nk.key, fcm_key_in_redis); // Key itself remains in metadata
    }
}
